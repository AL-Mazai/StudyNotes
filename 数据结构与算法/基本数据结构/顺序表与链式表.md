# 顺序表与链式表的优缺点比较

#### 一、空间上的比较（Space）

##### （一）空间的开辟：

顺序表：一般是连续开辟一段空间，然后在进行数据的增删查改（静态顺序表），所以顺序表一般是固定空间大小的。

单链表：一次只开辟一个结点的空间，用来存储当前要保存的数据及指向下一个结点或NULL的指针，所以单链表的空间大小时动态变化的。

<!--顺序表也可以在初始化时利用malloc函数来开辟一块空间，每当空间不够用时，再用realloc来把当前空间扩容成2倍，从而也能实现空间的动态变化（动态顺序表）。-->

##### （二）空间的使用：

a.不知道要存储多少数据时:

顺序表：用顺序表来开辟的空间如果太大，就会造成一定程度上的浪费。

单链表：每需要存储一个数据时，才开辟一个空间，虽然有非数据项的指针占空间，但相比顺序表来说，浪费不是那么明显。



b.知道存储的数据的数量时

用顺序表来开辟对应的空间大小，来存储数据，因为顺序表中每个元素的存储密度为 1，就完全不会有浪费的空间，而用单链表，因为每个结点都会有非数据项的指针，那么就会造成空间的浪费。再者，编译器会为每个程序从内存上分配一段空间，给该程序使用。然而我们每次开辟空间时都是在随机的位置开辟的，那么使用单链表，就会多次的在程序分配到的这块空间上开辟空间，因为每次都是开辟的位置都是随机的，那么可能会把这块空间搞得七零八碎，出现很多小的一般使用不到的碎片空间，这样很大程度上造成了空间的浪费，而使用顺序表的话，不会经常开辟空间，这样就减少了碎片空间的出现，那么就一定程度上节省了空间。



![](https://img-blog.csdn.net/20160323225820972)

![这里写图片描述](https://img-blog.csdn.net/20171009093521824?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbGp4XzU0ODk0NjQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



##### （三） 对CPU高速缓存的影响：

顺序表：空间一般是连续开辟的，而且一次会开辟存储多个元素的空间，所以在使用顺序表时，可以一次把多个数据写入高速缓存，再写入主存，**顺序表的CPU高速缓存效率更高，且CPU流水线也不会总是被打断**。

单链表：每需要存储一个数据才开辟一次空间，所以每个数据存储时都要单独的写入高速缓存区，再写入主存，这样就造成了，**单链表CPU高速缓存效率低，且CPU流水线会经常被打断**。



#### 二、时间上的比较（Time）

##### （一）访问（查找）随机元素的时间复杂度：

顺序表：结构像数组一样，可以用下标来访问它的元素，所以它的元素是支持随机访问的。**顺序表访问随机元素的时间复杂度是O(1)**。

单链表：数据是链式存储的，它的元素是不支持随机访问的，想要知道某个元素，只能从头结点开始遍历整个链表，知道找到了该元素为止。**单链表访问随机元素的时间复杂度是O(n)。**

##### （二） 随机位置插入、删除元素的时间复杂度：

顺序表：元素是连续存储的，因此要在特定位置插入、删除元素需要把它之后的元素全部后移或前移一个元素的位置，时间开销很大。**顺序表在随机位置插入、删除元素的平均时间复杂度是O(n)。**

单链表：在插入或删除元素时，只需要改变它的前驱元素及插入或删除元素的指向即可。**单链表在随机位置插入、删除元素的时间复杂度是O(1)。**

<!--一般来说线性表（顺序表和单链表都属于线性表）的插入删除操作会被执行的频繁一些，因此，使用单链表的频率较大。-->



总结：<!--在查询操作使用的比较频繁时，使用顺序表会好一些；在插入、删除操作使用的比较频繁时，使用单链表会好一些。-->